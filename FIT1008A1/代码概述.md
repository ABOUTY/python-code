## stats.py

包括两种不同的统计信息类型：`SimpleStats` 和 `ComplexStats`

`SimpleStats` 类接受固定的属性值，而 `ComplexStats` 类接受逆波兰表达式来计算属性值

包括攻击力、防御力、速度和最大生命值。

1. `Stats` 是一个抽象基类（ABC），它定义了四个抽象方法 `get_attack`、`get_defense`、`get_speed` 和 `get_max_hp`，用于获取角色的攻击力、防御力、速度和最大生命值。这里使用了 `abc.ABC` 来定义抽象基类。
2. `SimpleStats` 类是 `Stats` 的一个具体实现，它接受角色的攻击力、防御力、速度和最大生命值作为初始化参数，并将其保存在实例属性中。
3. `ComplexStats` 类也是 `Stats` 的一个具体实现，但它更为复杂。它的初始化方法接受四个参数，分别是用于计算攻击力、防御力、速度和最大生命值的逆波兰表达式数组。逆波兰表达式是一种后缀表示法，用于进行数学计算。
4. `evaluate_postfix` 方法用于计算逆波兰表达式的值。它使用了一个栈数据结构来实现计算过程。逐个遍历表达式中的操作数和操作符，并根据操作符进行相应的计算。支持的操作符包括加法、减法、乘法、除法、幂运算、平方根和一种称为 "middle" 的操作，用于找出三个数中的中间值。
5. `sqrt` 方法用于计算给定数字的平方根。它使用二分法来逼近平方根的值。
6. 对于 `get_attack`、`get_defense`、`get_speed` 和 `get_max_hp` 方法，它们分别使用 `evaluate_postfix` 方法计算角色在给定等级下的攻击力、防御力、速度和最大生命值。



例如:

```
array = ArrayR.from_list(["level","3","power","1","2", "3","middle", "*"])
```

先新建一个栈: stack

1. 从array中取值: level , 此时从数据里取level的值1, 并将1压入栈中, 此时stack = [1]

2. 从array取值: 3, 压入栈中, stack = [1, 3]
3. 从array中取得运算符 power , 此运算符需要2个数字运算, 因此从栈中取出1, 3, 3的1次方等于3, 因此将3压回栈中, stack = [3]
4. 从array取值: 1, 压入栈中, stack = [3, 1]
5. 从array取值: 2, 压入栈中, stack = [3, 1, 2]
6. 从array取值: 3, 压入栈中, stack = [3, 1, 2, 3]
7. 从array中取得运算符 middle , 此运算符需要3个数字运算, 因此从栈中取出3, 2, 1, 将2压回栈中, stack = [3 , 2]
8. 从array中取得运算符 * , 此运算符需要2个数字运算, 因此从栈中取出2, 3, 将2 * 3 = 6将6压回栈中, stack = [6]

此时array的值全部取完, 将栈的值取出得到表达式的值为6





## monster_base.py

`MonsterBase` 的抽象基类，表示游戏中的怪物（Monster）实例。

提供了一系列方法来处理怪物的属性、行为和特性，以及进化和计算攻击等操作。

1. 在 `__init__` 方法中，初始化了怪物的一些基本属性，例如初始等级、当前等级、生命值（hp）等。`simple_mode` 参数指定是否使用简单或复杂的统计信息。

2. `__str__` 方法返回一个字符串，表示怪物的当前状态，包括等级、名字和生命值。

3. 方法 `get_regenerate` 返回原始的怪物实例，用于队伍类的初始化要求。

4. `get_level` 方法返回当前怪物的等级。

5. `level_up` 方法用于使怪物升级，将等级增加1，同时根据当前生命值调整新等级的生命值。

6. 方法 `get_hp` 返回当前怪物的生命值。

7. 方法 `set_hp` 用于设置怪物的生命值。

8. 一系列 `get_attack`、`get_defense`、`get_speed` 和 `get_max_hp` 方法用于获取怪物的攻击、防御、速度和最大生命值。

9. `alive` 方法判断怪物是否还存活，即生命值是否大于0。

10. `attack` 方法用于怪物攻击另一个怪物，计算伤害并应用类型相克。

11. `ceiling` 方法用于对一个数字进行上取整。

12. `ready_to_evolve` 方法判断怪物是否可以进化。

13. `evolve` 方法用于怪物进化，返回一个进化后的怪物实例。

14. 还有一系列类方法，这些方法在具体的怪物类中需要被实现。它们包括获取怪物名字、描述、进化信息、元素属性等。还包括获取简单和复杂统计信息的方法。

## elements.py

实现了元素（Element）相克关系和效果计算相关的功能。

1. `Element` 是一个枚举类，用于表示不同的游戏元素。每个元素都有一个关联的值，这些值在枚举中使用 `auto()` 自动分配。
2. `from_string` 类方法用于从字符串中获取对应的元素。它遍历所有的元素枚举成员，如果名称（不区分大小写）匹配传入的字符串，则返回相应的枚举成员。
3. `EffectivenessCalculator` 类用于计算不同元素之间的相克效果。
4. 在 `__init__` 方法中，初始化了元素名称和相克效果值。这些信息通过传入两个数组，一个用于元素名称，另一个用于相克效果值。这些值是一个二维数组，对应不同元素对之间的相克效果。

## team.py

实现了一个名为 `MonsterTeam` 的类，用于管理游戏中的怪兽团队。

1. `MonsterTeam` 类包含了几个嵌套的枚举类，用于定义团队模式`TeamMode`、选取模式`SelectionMode`以及排序模式`SortMode`。
2. `TEAM_LIMIT` 是一个常量，表示团队的最大容量。
3. `__init__` 方法用于初始化一个怪兽团队。它接受一些参数，包括团队模式、选取模式以及其他参数。根据不同的参数，它会初始化团队的列表，选择不同的怪兽加入团队。
4. `add_to_team` 方法用于向团队中添加怪兽。根据团队模式，怪兽会被添加到不同的数据结构中，例如栈、队列或排序列表
5. `retrieve_from_team` 方法用于从团队中取出怪兽。根据团队模式，它会从相应的数据结构中取出怪兽并返回。
6. `special` 方法用于执行特殊的操作，根据不同的团队模式，它会对团队中的怪兽进行不同的重新排列或操作。
7. `regenerate_team` 方法用于重置团队的状态，将团队恢复到初始状态。
8. `select_randomly` 方法会随机选择一些怪兽加入团队。
9. `select_manually` 方法允许用户手动选择要加入团队的怪兽。
10. `select_provided` 方法根据提供的怪兽列表，将怪兽加入团队。

>在这里根据不同的`TeamMode`选取不同的数据结构作为`team_list`的结构,
>
>`FRONT`要求是先入后出, 采用栈`ArrayStack`的结构
>
>`BACK`要求是先入先出, 队列`CircularQueue`结构
>
>`OPTIMISE`要排序, 采用`ArraySortedList`结构

## tower.py

实现了一个名为 `BattleTower` 的类，用于模拟在游戏中进行怪兽战斗的竞技塔。

1. `BattleTower` 类用于管理怪兽战斗竞技塔的逻辑。它包含了一系列方法来处理战斗、团队等操作。

2. `MIN_LIVES` 和 `MAX_LIVES` 是常量，表示战斗中怪兽团队的最小和最大生命值。

3. `__init__` 方法用于初始化一个竞技塔，它可以接受一个 `Battle` 对象作为参数，如果没有传入，则创建一个默认的 `Battle` 对象。

4. `set_my_team` 方法用于设置玩家的怪兽团队，并为团队随机分配生命值, 并统计现在团队的元素加入总元素中

5. `generate_teams` 方法用于生成多个敌人团队，将它们添加到`enemy`队列中。

6. `battles_remaining` 方法用于检查是否还有剩余的战斗。如果玩家团队没有生命值或敌人队列为空，则返回 `False`。

7. `next_battle` 方法用于模拟下一场战斗，返回战斗结果、玩家团队、敌人团队、战斗后的玩家生命值和敌人生命值。

8. 这段代码块是 `next_battle` 方法的核心部分，它模拟了一场战斗，并更新了玩家和敌人团队的状态。以下是代码块的解释：

    1. 首先，检查 `self.battle_team` 是否为 `None`，如果是，则从敌人队列中取出一个团队作为战斗对手。

    2. 调用 `self.battle_team.regenerate_team()` 方法，将团队中怪物状态初始化。

    3. 将战斗对手团队的元素类型与已经出现过的元素类型进行合并，更新 `self.total_meta`。

    4. 调用 `self.my_team.regenerate_team()` 方法，将团队中怪物状态初始化。

    5. 创建一个 `BattleMock` 对象 `b`，用于模拟战斗。然后调用 `b.battle(self.my_team, self.battle_team)` 方法进行战斗，将结果存储在 `res` 变量中。

    6. 根据战斗结果（`res`），更新玩家团队和战斗对手团队的生命值。

        如果结果是 `Battle.Result.TEAM1`，则战斗对手团队的生命值减一

        如果结果是 `Battle.Result.TEAM2`，则玩家团队的生命值减一

        如果结果是 `Battle.Result.DRAW`，则两个团队的生命值都减一

    7. 如果战斗对手团队的生命值仍大于零，将其重新添加到敌人队列中, 供下一轮战斗使用

    8. 将 `self.battle_team` 存储在 `re_battle_team` 变量中，然后从敌人队列中取出下一个战斗对手，更新 `self.battle_team`。

    9. 返回战斗结果、玩家团队、原始的战斗对手团队、战斗后的玩家生命值和战斗对手生命值。

    总之，这段代码块模拟了一场战斗，并在每场战斗后更新了玩家和敌人团队的状态，包括生命值和元素类型。这样的逻辑确保了每次战斗后团队状态的正确性。

9. `out_of_meta` 方法用于获取没有用过的元素类型，即未出现在玩家团队和当前敌人团队的元素类型。

## Battle.py

怪兽对战游戏模拟，主要包括以下几个部分：

1. 枚举类定义：

- `Action` 枚举类：表示战斗中的动作，包括 `ATTACK`、`SWAP` 和 `SPECIAL`。
- `Result` 枚举类：表示战斗的结果，包括 `TEAM1`（队伍1获胜）、`TEAM2`（队伍2获胜）和 `DRAW`（平局）。

2. `Battle` 类的定义：

- `__init__` 方法：构造函数，初始化 `Battle` 类的实例，接受一个可选的 `verbosity` 参数来控制输出的详细程度。
- `process_turn` 方法：处理一轮战斗，计算双方怪兽的攻击和血量变化等情况，返回战斗结果或 `None`。

- `battle` 方法：执行完整的战斗，接受两支怪兽队伍作为参数，通过多次调用 `process_turn` 方法来模拟战斗的进行，最终返回战斗的结果。

其中`process_turn` 方法实现了一回合战斗的逻辑，包括双方怪兽的攻击、血量变化、怪兽升级进化、替换已倒下的怪兽等操作。

1. 检查战斗结果：
   首先，函数检查双方怪兽的状态，判断是否有一方或双方都没有剩余怪兽，从而决定战斗结果。
   - 如果双方怪兽都为空，返回 `Battle.Result.DRAW`，表示平局。
   - 如果某一方为空, 则胜利的是另一方。
2. 攻击阶段：
   根据双方怪兽的速度决定攻击顺序，速度较快的怪兽先攻击。攻击逻辑包括：
   - 如果 `self.out1` 的速度大于 `self.out2`，则 `self.out1` 攻击 `self.out2`，如果 `self.out2` 仍然存活，那么 `self.out2` 进行反击。
   - 如果两者速度相等，互相攻击对方。
3. 血量变化：
   如果双方怪兽都存活，那么在攻击阶段后，双方怪兽的血量都会减少1。
4. 怪兽状态处理：
   根据怪兽的存活情况进行不同的处理：
   - 如果两者都存活，继续下一回合，不做处理。
   - 如果 `self.out1` 存活而 `self.out2` 倒下，将 `self.out2` 从队伍2中移除，并从队伍2中取出新的怪兽替代。
     同时，对 `self.out1` 进行升级，如果满足进化条件，则进行进化。
   - 如果 `self.out2` 存活而 `self.out1` 倒下，类似地进行处理，将 `self.out1` 替换为新的怪兽，同时对 `self.out2` 进行升级和进化。
   - 如果双方怪兽都倒下，分别将队伍1和队伍2中的怪兽进行替换。

